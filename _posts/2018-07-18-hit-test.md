---
layout: post
title: 'iOS触摸事件处理'
date: 2018-07-18
author: Q.H.
tags: iOS
---

### Hit-Test找到响应消息view的流程

先用一张图来说明:
![Hit-Test](https://raw.githubusercontent.com/w-qihang/w-qihang.github.io/master/_posts/imgs/findView.png)

hitTest:withEvent:方法大致处理流程是这样的:
首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内：

+ 若pointInside:withEvent:方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest:withEvent:返回nil,然后去调用当前视图兄弟层级view的hitTest:withEvent:方法;

+ 若pointInside:withEvent:方法返回YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历，直到有子视图的hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕：

    - 若第一次有子视图的hitTest:withEvent:方法返回非空对象,则当前视图的hitTest:withEvent:方法就返回此对象，处理结束

    - 若所有子视图的hitTest:withEvent:方法都返回nil，则当前视图的hitTest:withEvent:方法返回当前视图自身(self)

最终，这个触摸事件交给主窗口的hitTest:withEvent:方法返回的视图对象去处理。拿到这个UIView后，就调用该UIView的touches系列方法。

可用代码解释UIView的hitTest方法执行过程如下:

```
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    //alpha值,userInteractionEnabled属性,hidden属性影响此方法
    if (self.alpha <= 0.01 || !self.userInteractionEnabled || self.hidden) {
        return nil;
    }
    if ([self pointInside:point withEvent:event]) {
        //遍历子view
        NSArray *subViews = [[self.subviews reverseObjectEnumerator] allObjects];
        for (UIView *subView in subViews) {
            //转换坐标系，然后判断该点是否在bounds范围内
            CGPoint convertedPoint = [self convertPoint:point toView:subView];
            UIView *tmpView = [subView hitTest:convertedPoint withEvent:event];
            if(tmpView) {
                return tmpView;
            }
        }
        return self;
    } else {
        return nil;
    }
}
```
### 响应链的传递
![Hit-Test](https://raw.githubusercontent.com/w-qihang/w-qihang.github.io/master/_posts/imgs/findView.png)

